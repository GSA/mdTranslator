# ISO 19115-1 <<Class>> MD_Metadata
# 19115-1 writer output in XML.

# History:
# 	Stan Smith 2019-03-12 original script

require 'uuidtools'
require 'adiwg/mdtranslator/internal/internal_metadata_obj'
require_relative '../iso19115_1_writer'
require_relative 'class_codelist'
require_relative 'class_identifier'
require_relative 'class_citation'
require_relative 'class_responsibility'
require_relative 'class_date'
require_relative 'class_locale'
require_relative 'class_onlineResource'
# require_relative 'class_spatialRepresentation'
# require_relative 'class_referenceSystem'
# require_relative 'class_extension'
# require_relative 'class_dataIdentification'
# require_relative 'class_coverageDescription'
# require_relative 'class_distribution'
# require_relative 'class_dataQuality'
# require_relative 'class_useConstraints'
# require_relative 'class_legalConstraints'
# require_relative 'class_securityConstraints'
# require_relative 'class_maintenance'
# require_relative 'class_gcoDateTime'

module ADIWG
   module Mdtranslator
      module Writers
         module Iso19115_1

            class MD_Metadata

               def initialize(xml, hResponseObj)
                  @xml = xml
                  @hResponseObj = hResponseObj
                  @NameSpace = ADIWG::Mdtranslator::Writers::Iso19115_1
               end

               def writeXML(intObj)

                  # classes used
                  intMetadataClass = InternalMetadata.new
                  codelistClass = MD_Codelist.new(@xml, @hResponseObj)
                  identifierClass = MD_Identifier.new(@xml, @hResponseObj)
                  citationClass = CI_Citation.new(@xml, @hResponseObj)
                  responsibilityClass = CI_Responsibility.new(@xml, @hResponseObj)
                  dateClass = CI_Date.new(@xml, @hResponseObj)
                  localeClass = PT_Locale.new(@xml, @hResponseObj)
                  onlineClass = CI_OnlineResource.new(@xml, @hResponseObj)
                  dataIdClass = MD_DataIdentification.new(@xml, @hResponseObj)
                  # representationClass = SpatialRepresentation.new(@xml, @hResponseObj)
                  # systemClass = MD_ReferenceSystem.new(@xml, @hResponseObj)
                  # extensionClass = MD_MetadataExtensionInformation.new(@xml, @hResponseObj)
                  # coverageClass = CoverageDescription.new(@xml, @hResponseObj)
                  # distClass = MD_Distribution.new(@xml, @hResponseObj)
                  # dqClass = DQ_DataQuality.new(@xml, @hResponseObj)
                  # uConClass = MD_Constraints.new(@xml, @hResponseObj)
                  # lConClass = MD_LegalConstraints.new(@xml, @hResponseObj)
                  # sConClass = MD_SecurityConstraints.new(@xml, @hResponseObj)
                  # maintenanceClass = MD_MaintenanceInformation.new(@xml, @hResponseObj)
                  # dateTimeClass = GcoDateTime.new(@xml, @hResponseObj)

                  # create shortcuts to sections of internal object
                  hMetadata = intObj[:metadata]
                  hMetaInfo = hMetadata[:metadataInfo]
                  hResInfo = hMetadata[:resourceInfo]
                  aAssocRes = hMetadata[:associatedResources]
                  aDistInfo = hMetadata[:distributorInfo]
                  version = @hResponseObj[:translatorVersion]

                  # document head
                  metadata = @xml.instruct! :xml, encoding: 'UTF-8'
                  @xml.comment!('ISO 19115-1 METADATA')
                  @xml.comment!('The following metadata file was constructed using the ADIwg mdTranslator, http://mdtranslator.adiwg.org')
                  @xml.comment!('mdTranslator software is an open-source project of the Alaska Data Integration working group (ADIwg)')
                  @xml.comment!('mdTranslator and other metadata tools are available at https://github.com/adiwg')
                  @xml.comment!('ADIwg is not responsible for the content of this metadata record')
                  @xml.comment!('This metadata record was generated by mdTranslator ' + version + ' at ' + Time.now.to_s)

                  # MD_Metadata
                  @xml.tag!('mdb:MD_Metadata',
                            {'xmlns:gml' => 'www.opengis.net/gml.3.2',
                             'xmlns:mdb' => 'http://standards.iso.org/iso/19115/-3/mdb/1.0',
                             'xmlns:gco' => 'http://standards.iso.org/iso/19115/-3/gco/1.0',
                             'xmlns:mcc' => 'http://standards.iso.org/iso/19115/-3/mcc/1.0',
                             'xmlns:lan' => 'http://standards.iso.org/iso/19115/-3/lan/1.0',
                             'xmlns:cit' => 'http://standards.iso.org/iso/19115/-3/cit/1.0',
                             'xmlns:gex' => 'http://standards.iso.org/iso/19115/-3/gex/1.0',
                             'xmlns:mco' => 'http://standards.iso.org/iso/19115/-3/mco/1.0',
                             'xmlns:mri' => 'http://standards.iso.org/iso/19115/-3/mri/1.0',
                             'xmlns:mrc' => 'http://standards.iso.org/iso/19115/-3/mrc/1.0',
                             'xmlns:mrd' => 'http://standards.iso.org/iso/19115/-3/mrd/1.0',
                             'xmlns:mda' => 'http://standards.iso.org/iso/19115/-3/mda/1.0',
                             'xmlns:mrl' => 'http://standards.iso.org/iso/19115/-3/mrl/1.0',
                             'xmlns:mrs' => 'http://standards.iso.org/iso/19115/-3/mrs/1.0',
                             'xmlns:msr' => 'http://standards.iso.org/iso/19115/-3/msr/1.0',
                             'xmlns:mmi' => 'http://standards.iso.org/iso/19115/-3/mmi/1.0',
                             'xmlns:srv' => 'http://standards.iso.org/iso/19115/-3/srv/2.0',
                             'xmlns:gfc' => 'http://standards.iso.org/iso/19110/gfc/1.1',
                             'xmlns:fcc' => 'http://standards.iso.org/iso/19110/fcc/1.0',
                             'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
                             }) do

                     # metadata information - metadata identifier {MD_Identifier} (default: UUID)
                     hMetadataId = hMetaInfo[:metadataIdentifier].empty?
                     if hMetadataId.empty?
                        hIdentifier = intMetadataClass.newIdentifier
                        hIdentifier[:identifier] = UUIDTools::UUID.random_create.to_s
                        hIdentifier[:namespace] = 'UUID'
                     end
                     @xml.tag!('mdb:metadataIdentifier') do
                        identifierClass.writeXML(hMetadataId, outContext)
                     end

                     # metadata information - default locale {PT_Locale} (default: USA, English, UTF-8)
                     hDefLocale = hMetaInfo[:defaultMetadataLocale]
                     if hDefLocale.empty?
                        hDefLocale = intMetadataClass.newLocale
                        hDefLocale[:languageCode] = 'eng'
                        hDefLocale[:countryCode] = 'USA'
                        hDefLocale[:characterEncoding] = 'UTF-8'
                     end
                     @xml.tag!('mdb:defaultLocale') do
                        identifierClass.writeXML(hDefLocale, outContext)
                     end

                     # metadata information - parent metadata {CI_Citation}
                     unless hMetaInfo[:parentMetadata].empty?
                        @xml.tag!('mdb:parentMetadata') do
                           citationClass.writeXML(hMetaInfo[:parentMetadata], 'metadata information')
                        end
                     end
                     if hMetaInfo[:parentMetadata].empty? && @hResponseObj[:writerShowTags]
                        @xml.tag!('mdb:parentMetadata')
                     end

                     # metadata information - metadata scope [] {MD_Scope}
                     aScope = hResInfo[:resourceTypes]
                     aScope.each do |hScope|
                        unless hScope[:type].nil?
                           @xml.tag!('mdb:metadataScope') do
                              @xml.tag!('mdb:MD_MetadataScope', hScope[:type])
                           end
                        end
                        if hScope[:type].nil?
                           @NameSpace.issueWarning(390, 'mdb:metadataScope', 'resource information')
                        end
                     end
                     if aScope.empty? && @hResponseObj[:writerShowTags]
                        @xml.tag!('mdb:metadataScope')
                     end

                     # metadata information - contact [] {CI_ResponsibleParty} (required)
                     aContacts = hMetaInfo[:metadataContacts]
                     aContacts.each do |hContact|
                        unless hContact.empty?
                           @xml.tag!('mdb:contact') do
                              responsibilityClass.writeXML(hContact, 'metadata information')
                           end
                        end
                     end
                     if aContacts.empty?
                        @NameSpace.issueWarning(240, 'mdb:contact', 'metadata information')
                     end

                     # metadata information - date info [] {CI_Date} (required)
                     # 'creation' date is required - default: now()
                     aDates = hMetaInfo[:metadataDates]
                     haveCreation = false
                     aDates.each do |hDate|
                        if hDate[:dateType] == 'creation'
                           haveCreation = true
                        end
                     end
                     unless haveCreation
                        hCreateDate = {}
                        hCreateDate[:date] = DateTime.now
                        hCreateDate[:dateResolution] = 'YMD'
                        aDates.insert(0, hCreateDate)
                     end
                     aDates.each do |hDate|
                        @xml.tag!('mdb:dateInfo') do
                           dateClass.writeXML(hDate, 'metadata information')
                        end
                     end

                     # metadata information - metadata standard [] {CI_Citation} (auto fill)
                     hStandard = intMetadataClass.newCitation
                     hStandard[:title] = 'ISO 19115-3'
                     @xml.tag!('mdb:metadataStandard') do
                        citationClass.writeXML(hStandard, 'metadata standard')
                     end

                     # metadata information - metadata profile [] {CI_Citation} (auto fill)
                     hProfile = intMetadataClass.newCitation
                     hProfile[:title] = 'ISO 19115-1:2014-04-01'
                     @xml.tag!('mdb:metadataStandard') do
                        citationClass.writeXML(hProfile, 'metadata profile')
                     end

                     # metadata information - alternate metadata reference [] {CI_Citation}
                     aAlternates = hMetaInfo[:alternateMetadataReferences]
                     aAlternates.each do |hAlternate|
                        @xml.tag!('mdb:alternativeMetadataReference') do
                           citationClass.writeXML(hAlternate, 'metadata alternate')
                        end
                     end
                     if aAlternates.empty && @hResponseObj[:writerShowTags]
                        @xml.tag!('mdb:alternativeMetadataReference')
                     end

                     # metadata information - other locale [] {PT_Locale}
                     aLocales = hMetaInfo[:otherMetadataLocales]
                     aLocales.each do |hLocale|
                        @xml.tag!('mdb:otherLocale') do
                           localeClass.writeXML(hLocale, 'other metadata locale')
                        end
                     end
                     if aLocales.empty && @hResponseObj[:writerShowTags]
                        @xml.tag!('mdb:otherLocale')
                     end

                     # metadata information - metadata linkage [] {CI_OnlineResource}
                     aLinks = hMetaInfo[:metadataLinkages]
                     aLinks.each do |hLink|
                        @xml.tag!('mdb:metadataLinkage') do
                           onlineClass.writeXML(hLink, 'metadata online resource')
                        end
                     end
                     if aLinks.empty && @hResponseObj[:writerShowTags]
                        @xml.tag!('mdb:metadataLinkage')
                     end

                     # ###################### Begin Data Identification #####################

                     # metadata information - data identification info - required
                     unless hResInfo.empty?
                        @xml.tag!('mdb:identificationInfo') do
                           dataIdClass.writeXML(hResInfo, aAssocRes, aDistInfo)
                        end
                     end
                     if hResInfo.empty?
                        @NameSpace.issueWarning(241, 'mdb:identificationInfo')
                     end

                     # ###################### End Data Identification #######################




                     # # metadata information - coverageDescription []
                     # aItems = hResInfo[:coverageDescriptions]
                     # aItems.each do |hCoverage|
                     #
                     #    # mdJson follows ISO 19115-1 for this section
                     #    # in ISO 19115-1
                     #    # coverageDescription << attributeGroup << attribute (rangeDimension)
                     #    # in ISO 19115-2
                     #    # coverageDescription << attribute (rangeDimension)
                     #    # how to handle in ISO 19115-2 ...
                     #    # break up attributeGroup, handle each in separate coverageDescription
                     #    # handle image and attributeGroup in separate coverageDescriptions
                     #    # also allow both attributeGroup and imageDescription to be empty
                     #
                     #    if hCoverage[:imageDescription].empty? && hCoverage[:attributeGroups].empty?
                     #       @xml.tag!('gmd:contentInfo') do
                     #          coverageClass.writeXML(hCoverage)
                     #       end
                     #    end
                     #
                     #    unless hCoverage[:imageDescription].empty?
                     #       hInstance = Marshal::load(Marshal.dump(hCoverage))
                     #       hInstance[:attributeGroups] = []
                     #       @xml.tag!('gmd:contentInfo') do
                     #          coverageClass.writeXML(hInstance)
                     #       end
                     #    end
                     #
                     #    hCoverage[:attributeGroups].each do |hGroup|
                     #       hInstance = Marshal::load(Marshal.dump(hCoverage))
                     #       hInstance[:imageDescription] = {}
                     #       hInstance[:attributeGroups] = []
                     #       hInstance[:attributeGroups] << hGroup
                     #       @xml.tag!('gmd:contentInfo') do
                     #          coverageClass.writeXML(hInstance)
                     #       end
                     #    end
                     #
                     # end
                     # if aItems.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:contentInfo')
                     # end
                     #
                     # # metadata information - distribution info [0]
                     # unless aDistInfo.empty?
                     #    hDistInfo = aDistInfo[0]
                     #    unless hDistInfo.empty?
                     #       @xml.tag!('gmd:distributionInfo') do
                     #          distClass.writeXML(hDistInfo)
                     #       end
                     #    end
                     # end
                     # if aDistInfo.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:distributionInfo')
                     # end
                     #
                     # # metadata information - data quality info []
                     # aDQInfo = hMetadata[:lineageInfo]
                     # aDQInfo.each do |hDQInfo|
                     #    @xml.tag!('gmd:dataQualityInfo') do
                     #       dqClass.writeXML(hDQInfo)
                     #    end
                     # end
                     # if aDQInfo.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:dataQualityInfo')
                     # end
                     #
                     # # metadata information - metadata constraints {}
                     # aCons = hMetaInfo[:metadataConstraints]
                     # aCons.each do |hCon|
                     #    @xml.tag!('gmd:metadataConstraints') do
                     #       type = hCon[:type]
                     #       if type == 'use'
                     #          uConClass.writeXML(hCon)
                     #       end
                     #       if type == 'legal'
                     #          lConClass.writeXML(hCon)
                     #       end
                     #       if type == 'security'
                     #          sConClass.writeXML(hCon)
                     #       end
                     #    end
                     # end
                     # if aCons.nil? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:metadataConstraints')
                     # end
                     #
                     # # metadata information - metadata maintenance
                     # hMaintenance = hMetaInfo[:metadataMaintenance]
                     # unless hMaintenance.empty?
                     #    @xml.tag!('gmd:metadataMaintenance') do
                     #       maintenanceClass.writeXML(hMaintenance, 'metadata maintenance')
                     #    end
                     # end
                     # if hMaintenance.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:metadataMaintenance')
                     # end

                  end # mdb:MD_Metadata tag

                  return metadata

               end # writeXML
            end # MI_Metadata class

         end
      end
   end
end
