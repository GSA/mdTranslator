# ISO 19115-1 <<Class>> MD_Metadata
# 19115-1 writer output in XML.

# History:
# 	Stan Smith 2019-03-12 original script

require 'uuidtools'
require 'adiwg/mdtranslator/internal/internal_metadata_obj'
require_relative '../iso19115_1_writer'
require_relative 'class_codelist'
require_relative 'class_identifier'
require_relative 'class_citation'
# require_relative 'class_hierarchy'
# require_relative 'class_responsibleParty'
# require_relative 'class_locale'
# require_relative 'class_spatialRepresentation'
# require_relative 'class_referenceSystem'
# require_relative 'class_extension'
# require_relative 'class_dataIdentification'
# require_relative 'class_coverageDescription'
# require_relative 'class_distribution'
# require_relative 'class_dataQuality'
# require_relative 'class_useConstraints'
# require_relative 'class_legalConstraints'
# require_relative 'class_securityConstraints'
# require_relative 'class_maintenance'
# require_relative 'class_gcoDateTime'

module ADIWG
   module Mdtranslator
      module Writers
         module Iso19115_1

            class MD_Metadata

               def initialize(xml, hResponseObj)
                  @xml = xml
                  @hResponseObj = hResponseObj
                  @NameSpace = ADIWG::Mdtranslator::Writers::Iso19115_1
               end

               def writeXML(intObj)

                  # classes used
                  intMetadataClass = InternalMetadata.new
                  codelistClass = MD_Codelist.new(@xml, @hResponseObj)
                  identifierClass = MD_Identifier.new(@xml, @hResponseObj)
                  citationClass = CI_Citation.new(@xml, @hResponseObj)
                  # partyClass = CI_ResponsibleParty.new(@xml, @hResponseObj)
                  # hierarchyClass = Hierarchy.new(@xml, @hResponseObj)
                  # localeClass = PT_Locale.new(@xml, @hResponseObj)
                  # representationClass = SpatialRepresentation.new(@xml, @hResponseObj)
                  # systemClass = MD_ReferenceSystem.new(@xml, @hResponseObj)
                  # extensionClass = MD_MetadataExtensionInformation.new(@xml, @hResponseObj)
                  # dataIdClass = MD_DataIdentification.new(@xml, @hResponseObj)
                  # coverageClass = CoverageDescription.new(@xml, @hResponseObj)
                  # distClass = MD_Distribution.new(@xml, @hResponseObj)
                  # dqClass = DQ_DataQuality.new(@xml, @hResponseObj)
                  # uConClass = MD_Constraints.new(@xml, @hResponseObj)
                  # lConClass = MD_LegalConstraints.new(@xml, @hResponseObj)
                  # sConClass = MD_SecurityConstraints.new(@xml, @hResponseObj)
                  # maintenanceClass = MD_MaintenanceInformation.new(@xml, @hResponseObj)
                  # dateTimeClass = GcoDateTime.new(@xml, @hResponseObj)

                  # create shortcuts to sections of internal object
                  hMetadata = intObj[:metadata]
                  hMetaInfo = hMetadata[:metadataInfo]
                  hResInfo = hMetadata[:resourceInfo]
                  aAssocRes = hMetadata[:associatedResources]
                  aDistInfo = hMetadata[:distributorInfo]
                  version = @hResponseObj[:translatorVersion]

                  outContext = 'Metadata'

                  # document head
                  metadata = @xml.instruct! :xml, encoding: 'UTF-8'
                  @xml.comment!('ISO 19115-1 METADATA')
                  @xml.comment!('The following metadata file was constructed using the ADIwg mdTranslator, http://mdtranslator.adiwg.org')
                  @xml.comment!('mdTranslator software is an open-source project of the Alaska Data Integration working group (ADIwg)')
                  @xml.comment!('mdTranslator and other metadata tools are available at https://github.com/adiwg')
                  @xml.comment!('ADIwg is not responsible for the content of this metadata record')
                  @xml.comment!('This metadata record was generated by mdTranslator ' + version + ' at ' + Time.now.to_s)

                  # MD_Metadata
                  @xml.tag!('gmi:MI_Metadata',
                            {'xmlns:gml' => 'www.opengis.net/gml.3.2',
                             'xmlns:mdb' => 'http://standards.iso.org/iso/19115/-3/mdb/1.0',
                             'xmlns:gco' => 'http://standards.iso.org/iso/19115/-3/gco/1.0',
                             'xmlns:mcc' => 'http://standards.iso.org/iso/19115/-3/mcc/1.0',
                             'xmlns:lan' => 'http://standards.iso.org/iso/19115/-3/lan/1.0',
                             'xmlns:cit' => 'http://standards.iso.org/iso/19115/-3/cit/1.0',
                             'xmlns:gex' => 'http://standards.iso.org/iso/19115/-3/gex/1.0',
                             'xmlns:mco' => 'http://standards.iso.org/iso/19115/-3/mco/1.0',
                             'xmlns:mri' => 'http://standards.iso.org/iso/19115/-3/mri/1.0',
                             'xmlns:mrc' => 'http://standards.iso.org/iso/19115/-3/mrc/1.0',
                             'xmlns:mrd' => 'http://standards.iso.org/iso/19115/-3/mrd/1.0',
                             'xmlns:mda' => 'http://standards.iso.org/iso/19115/-3/mda/1.0',
                             'xmlns:mrl' => 'http://standards.iso.org/iso/19115/-3/mrl/1.0',
                             'xmlns:mrs' => 'http://standards.iso.org/iso/19115/-3/mrs/1.0',
                             'xmlns:msr' => 'http://standards.iso.org/iso/19115/-3/msr/1.0',
                             'xmlns:mmi' => 'http://standards.iso.org/iso/19115/-3/mmi/1.0',
                             'xmlns:srv' => 'http://standards.iso.org/iso/19115/-3/srv/2.0',
                             'xmlns:gfc' => 'http://standards.iso.org/iso/19110/gfc/1.1',
                             'xmlns:fcc' => 'http://standards.iso.org/iso/19110/fcc/1.0',
                             'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
                             }) do

                     # metadata information - metadata identifier {MD_Identifier} (default: UUID)
                     hMetadataId = hMetaInfo[:metadataIdentifier].empty?
                     if hMetadataId.empty?
                        hIdentifier = intMetadataClass.newIdentifier
                        hIdentifier[:identifier] = UUIDTools::UUID.random_create.to_s
                        hIdentifier[:namespace] = 'UUID'
                     end
                     @xml.tag!('mdb:metadataIdentifier') do
                        identifierClass.writeXML(hMetadataId, outContext)
                     end

                     # metadata information - default locale {PT_Locale} (default: USA, English, UTF-8)
                     hDefLocale = hMetaInfo[:defaultMetadataLocale]
                     if hDefLocale.empty?
                        hDefLocale = intMetadataClass.newLocale
                        hDefLocale[:languageCode] = 'eng'
                        hDefLocale[:countryCode] = 'USA'
                        hDefLocale[:characterEncoding] = 'UTF-8'
                     end
                     @xml.tag!('mdb:defaultLocale') do
                        identifierClass.writeXML(hDefLocale, outContext)
                     end

                     # metadata information - parent metadata {CI_Citation}
                     unless hMetaInfo[:parentMetadata].empty?
                        @xml.tag!('mdb:parentMetadata') do
                           citationClass.writeXML(hMetaInfo[:parentMetadata], outContext)
                        end
                     end
                     if hMetaInfo[:parentMetadata].empty? && @hResponseObj[:writerShowTags]
                        @xml.tag!('mdb:parentMetadata')
                     end

                     # metadata information - metadata scope [] {MD_Scope}
                     # not implemented




                     # metadata information - contact [] {CI_ResponsibleParty} (required)
                     # metadata information - date info [] {CI_Date} (required)
                     # metadata information - metadata standard [] {CI_Citation} (auto fill)
                     # metadata information - metadata profile [] {CI_Citation} (auto fill)
                     # metadata information - alternate metadata reference [] {CI_Citation} (auto fill)
                     # metadata information - other locale [] {PT_Locale}
                     # metadata information - metadata linkage [] {CI_OnlineResource}

                     ###################################################################################################

                     # # metadata information - hierarchy level [] {MD_scopeCode}
                     # # metadata information - hierarchy level Name [] {string}
                     # # hierarchy comes from resourceInfo < resourceType []
                     # # pass entire array to hierarchy
                     # # all hierarchyLevel tags must precede the hierarchyLevelName tags
                     # aResTypes = hResInfo[:resourceTypes]
                     # unless aResTypes.empty?
                     #    hierarchyClass.writeXML(aResTypes)
                     # end
                     # if aResTypes.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:hierarchyLevel')
                     #    @xml.tag!('gmd:hierarchyLevelName')
                     # end
                     #
                     # # metadata information - metadata contact [] (required)
                     # # [{CI_ResponsibleParty}]
                     # aRParties = hMetaInfo[:metadataContacts]
                     # aRParties.each do |hRParty|
                     #    role = hRParty[:roleName]
                     #    aParties = hRParty[:parties]
                     #    aParties.each do |hParty|
                     #       @xml.tag!('gmd:contact') do
                     #          partyClass.writeXML(role, hParty, 'metadata contact')
                     #       end
                     #    end
                     # end
                     # if aRParties.empty?
                     #    @NameSpace.issueWarning(240, 'gmd:contact')
                     # end
                     #
                     # # metadata information - date stamp (required) {default: now()}
                     # hCreateDate = {}
                     # hCreateDate[:date] = DateTime.now
                     # hCreateDate[:dateResolution] = 'YMD'
                     # aDates = hMetaInfo[:metadataDates]
                     # aDates.each do |hDate|
                     #    if hDate[:dateType] == 'creation'
                     #       hCreateDate = hDate
                     #    end
                     # end
                     # @xml.tag!('gmd:dateStamp') do
                     #    dateTimeClass.writeXML(hCreateDate)
                     # end
                     #
                     # # metadata information - metadata standard name (default)
                     # @xml.tag!('gmd:metadataStandardName') do
                     #    @xml.tag!('gco:CharacterString', 'ISO 19115-2')
                     # end
                     #
                     # # metadata information - metadata standard version (default)
                     # @xml.tag!('gmd:metadataStandardVersion') do
                     #    @xml.tag!('gco:CharacterString', 'ISO 19115-2:2009(E)')
                     # end
                     #
                     # # metadata information - metadata linkage
                     # s = nil
                     # unless hMetaInfo[:metadataLinkages].empty?
                     #    hLinkage = hMetaInfo[:metadataLinkages][0]
                     #    s = hLinkage[:olResURI]
                     #    @xml.tag!('gmd:dataSetURI') do
                     #       @xml.tag!('gco:CharacterString', s)
                     #    end
                     # end
                     # if s.nil? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:dataSetURI')
                     # end
                     #
                     # # metadata information - locale []
                     # aLocales = hMetaInfo[:otherMetadataLocales]
                     # unless hMetaInfo[:defaultMetadataLocale].empty?
                     #    aLocales.insert(0, hMetaInfo[:defaultMetadataLocale])
                     # end
                     # aLocales.each do |hLocale|
                     #    @xml.tag!('gmd:locale') do
                     #       localeClass.writeXML(hLocale, 'metadata information locale')
                     #    end
                     # end
                     # if aLocales.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:locale')
                     # end
                     #
                     # # metadata information - spatial representation []
                     # aReps = hResInfo[:spatialRepresentations]
                     # aReps.each do |hRep|
                     #    @xml.tag!('gmd:spatialRepresentationInfo') do
                     #       representationClass.writeXML(hRep)
                     #    end
                     # end
                     # if aReps.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:spatialRepresentationInfo')
                     # end
                     #
                     # # metadata information - reference system []
                     # aSystems = hResInfo[:spatialReferenceSystems]
                     # aSystems.each do |hSystem|
                     #    # reference systems with referenceType only are not supported in 19115-2
                     #    unless hSystem[:systemIdentifier].empty? && hSystem[:systemParameterSet].empty?
                     #       @xml.tag!('gmd:referenceSystemInfo') do
                     #          systemClass.writeXML(hSystem)
                     #       end
                     #    end
                     # end
                     # if aSystems.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:referenceSystemInfo')
                     # end
                     #
                     # # metadata information - metadata extension info
                     # # add biological profile to all metadata records
                     # intBio = intMetadataClass.newMetadataExtension
                     # intBio[:name] = 'Taxonomy System'
                     # intBio[:shortName] = 'TaxonSys'
                     # intBio[:definition] = 'Documentation of taxonomic sources, procedures, and treatments'
                     # intBio[:obligation] = 'optional'
                     # intBio[:dataType] = 'class'
                     # intBio[:maxOccurrence] = '1'
                     # intBio[:parentEntities] << 'MD_Identification'
                     # intBio[:rule] = 'New Metadata section as a class to MD_Identification'
                     # intBio[:rationales] << 'The set of data elements contained within this class element ' +
                     #    'represents an attempt to provide better documentation of ' +
                     #    'taxonomic sources, procedures, and treatments.'
                     # intBio[:sourceOrganization] = 'National Biological Information Infrastructure'
                     # intBio[:sourceURI] = 'https://www2.usgs.gov/core_science_systems/Access/p1111-1.html'
                     # intBio[:sourceRole] = 'author'
                     #
                     # @xml.tag!('gmd:metadataExtensionInfo') do
                     #    extensionClass.writeXML(intBio)
                     # end
                     #
                     # # ###################### Begin Data Identification #####################
                     #
                     # # metadata information - identification info - required
                     # unless hResInfo.empty?
                     #    @xml.tag!('gmd:identificationInfo') do
                     #       dataIdClass.writeXML(hResInfo, aAssocRes, aDistInfo)
                     #    end
                     # end
                     # if hResInfo.empty?
                     #    @NameSpace.issueWarning(241, 'gmd:identificationInfo')
                     # end
                     #
                     # # ###################### End Data Identification #######################
                     #
                     # # metadata information - coverageDescription []
                     # aItems = hResInfo[:coverageDescriptions]
                     # aItems.each do |hCoverage|
                     #
                     #    # mdJson follows ISO 19115-1 for this section
                     #    # in ISO 19115-1
                     #    # coverageDescription << attributeGroup << attribute (rangeDimension)
                     #    # in ISO 19115-2
                     #    # coverageDescription << attribute (rangeDimension)
                     #    # how to handle in ISO 19115-2 ...
                     #    # break up attributeGroup, handle each in separate coverageDescription
                     #    # handle image and attributeGroup in separate coverageDescriptions
                     #    # also allow both attributeGroup and imageDescription to be empty
                     #
                     #    if hCoverage[:imageDescription].empty? && hCoverage[:attributeGroups].empty?
                     #       @xml.tag!('gmd:contentInfo') do
                     #          coverageClass.writeXML(hCoverage)
                     #       end
                     #    end
                     #
                     #    unless hCoverage[:imageDescription].empty?
                     #       hInstance = Marshal::load(Marshal.dump(hCoverage))
                     #       hInstance[:attributeGroups] = []
                     #       @xml.tag!('gmd:contentInfo') do
                     #          coverageClass.writeXML(hInstance)
                     #       end
                     #    end
                     #
                     #    hCoverage[:attributeGroups].each do |hGroup|
                     #       hInstance = Marshal::load(Marshal.dump(hCoverage))
                     #       hInstance[:imageDescription] = {}
                     #       hInstance[:attributeGroups] = []
                     #       hInstance[:attributeGroups] << hGroup
                     #       @xml.tag!('gmd:contentInfo') do
                     #          coverageClass.writeXML(hInstance)
                     #       end
                     #    end
                     #
                     # end
                     # if aItems.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:contentInfo')
                     # end
                     #
                     # # metadata information - distribution info [0]
                     # unless aDistInfo.empty?
                     #    hDistInfo = aDistInfo[0]
                     #    unless hDistInfo.empty?
                     #       @xml.tag!('gmd:distributionInfo') do
                     #          distClass.writeXML(hDistInfo)
                     #       end
                     #    end
                     # end
                     # if aDistInfo.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:distributionInfo')
                     # end
                     #
                     # # metadata information - data quality info []
                     # aDQInfo = hMetadata[:lineageInfo]
                     # aDQInfo.each do |hDQInfo|
                     #    @xml.tag!('gmd:dataQualityInfo') do
                     #       dqClass.writeXML(hDQInfo)
                     #    end
                     # end
                     # if aDQInfo.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:dataQualityInfo')
                     # end
                     #
                     # # metadata information - metadata constraints {}
                     # aCons = hMetaInfo[:metadataConstraints]
                     # aCons.each do |hCon|
                     #    @xml.tag!('gmd:metadataConstraints') do
                     #       type = hCon[:type]
                     #       if type == 'use'
                     #          uConClass.writeXML(hCon)
                     #       end
                     #       if type == 'legal'
                     #          lConClass.writeXML(hCon)
                     #       end
                     #       if type == 'security'
                     #          sConClass.writeXML(hCon)
                     #       end
                     #    end
                     # end
                     # if aCons.nil? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:metadataConstraints')
                     # end
                     #
                     # # metadata information - metadata maintenance
                     # hMaintenance = hMetaInfo[:metadataMaintenance]
                     # unless hMaintenance.empty?
                     #    @xml.tag!('gmd:metadataMaintenance') do
                     #       maintenanceClass.writeXML(hMaintenance, 'metadata maintenance')
                     #    end
                     # end
                     # if hMaintenance.empty? && @hResponseObj[:writerShowTags]
                     #    @xml.tag!('gmd:metadataMaintenance')
                     # end

                  end # gmi:MI_Metadata tag

                  return metadata

               end # writeXML
            end # MI_Metadata class

         end
      end
   end
end
