#!/usr/bin/env ruby
# ADIwg mdTranslator - Thor CLI for mdtranslator

# History:
# 	Stan Smith 2014-07-15 original script
#   Stan Smith 2014-09-02 changed name to mdtranslator
#   Stan Smith 2014-09-21 coded cli to 0.8.0 api
#   Stan Smith 2014-10-09 added version command to the CLI
#   Stan Smith 2014-12-29 changed default reader from adiwgJson to mdJson
#   Stan Smith 2015-01-15 changed translate method to use keyword arguments

require 'thor'
require 'adiwg-mdtranslator'

class Mdtranslator < Thor

	# exit_on_failure added to exit with code 1 if thor cannot complete task
	# such as if required parameters are missing
	def self.exit_on_failure?
		true
	end

	# basic cli description
	desc 'translate [FILE]', %q{Pass JSON string or filename plus parameters to mdtranslator translate}
	long_desc <<-LONGDESC
	'mdtranslator translate' provides command line access to the ADIWG metadata translator
with options to select the input file reader, select writer output format, show empty tags
in XML outputs, and choose level of validation for JSON inputs.
	LONGDESC
	# define cli options
	method_option :reader, :aliases => '-r', :desc => 'Reader to read your input metadata file', :enum => %w{mdJson}, :required => true
	method_option :writer, :aliases => '-w', :desc => 'Writer to create your output metadata file, leave blank to validate input only', :enum => %w{iso19115_2 iso19110 html}
	method_option :validate, :aliases => '-v', :desc => 'Specify level of validation to be performed', :enum => %w{none normal strict}, :default => 'normal'
	method_option :showAllTags, :aliases => '-s', :desc => 'Include tags for unused attributes', :type => :boolean, :default => false
	method_option :messages, :aliases => '-m', :desc => 'On error return messages as formatted text or json object', :enum => %w{json text}, :default => 'text'
	method_option :returnObject, :aliases => '-o', :desc => 'Return full JSON object generated by translator', :type => :boolean, :default => false

	# accept command and options
	def translate(file)

		# test to see if file parameter is a local file
		# if not ... it is assumed to be a json string
		if File.exist?(file)
			# read file
			my_file = File.open(file, 'r')
			fileObj = my_file.read
			my_file.close
		else
			fileObj = file
		end

		# call mdtranslator
        mdReturn = ADIWG::Mdtranslator.translate(
            file: fileObj,
            reader: options[:reader],
            writer: options[:writer],
            validate: options[:validate],
            showAllTags: options[:showAllTags])

		# determine return content and type of return ...
		if mdReturn[:readerStructurePass] && mdReturn[:readerValidationPass]

			# no problem was found with the input file
			if options[:writer].nil?
				# if no writer was specified the input was being validated only,
				# ...no writer output will have been generated,
				# ...and the return will be a string unless json was requested
				if options[:messages] == 'json'
					$stdout.puts mdReturn.to_json
					return
				else
					$stdout.puts 'Success'
					return
				end
			else
				# a writer was specified,
				# output is expected from the translator's writer
				if mdReturn[:writerPass]
				    # writer output was generated
					# ...return the writer output in its native format unless json was requested
					if options[:returnObject]
						$stdout.puts mdReturn.to_json
						return
					else
						$stdout.puts mdReturn[:writerOutput].to_s
						return
					end
				else
					# the writer failed or generated warnings to be reported
					# ...return the messages as a string unless json was requested
					if options[:messages] == 'json'
						$stdout.puts mdReturn.to_json
						return
					else
						# build a string with messages issues from parser and validator
						s = ''
						s += "Failed\n"
						s += "Writer failed to generate output or issued significant warnings\n"
						s += "See following messages for further information\n"

						# post structure messages
						i = 0
						mdReturn[:writerMessages].each do |message|
							i += 1
							s += "\nMessage: #{i}\n"
							s += message + "\n"
						end

						$stdout.puts s
						return

					end
				end
			end

		else

			# problems were found with the input file

			# if no writer was specified the input was being validated only,
			# ...no writer output will have been generated,
			# ...and return is always expected to be a string
			if options[:messages] == 'json'
				$stdout.puts mdReturn.to_json
				return
			else
				# build a string with messages issues from parser and validator
				s = ''
				s += "Failed\n"
				s += "Input failed to pass either file structure validation or content does not match schema\n"
				s += "See following messages for further information\n"

				# post structure messages
				if mdReturn[:readerStructurePass]
					s += "Success - Input structure is valid\n"
				else
					s += "Fail - Structure of input file is invalid - see following message(s):\n"
					i = 0
					mdReturn[:readerStructureMessages].each do |message|
						i += 1
						s += "\nMessage: #{i}\n"
						s += message.to_s + "\n"
					end
				end

				# post validator messages
				unless mdReturn[:readerValidationPass].nil?
					if mdReturn[:readerValidationPass]
						s += "Success - Input content passes schema definition\n"
					else
						s += "Fail - Input content did not pass schema validation - see following message(s):\n"
						i = 0
						mdReturn[:readerValidationMessages].each do |message|
							i += 1
							s += "\nMessage: #{i}\n"
							s += message.to_s + "\n"
						end
					end
				end

				$stdout.puts s
				return

			end
		end

	end

	desc 'version', %q{Returns the version of mdTranslator}
	long_desc <<-LONGDESC
		'mdtranslator version' returns the version number for mdTranslator
	LONGDESC
	def version
		$stdout.puts ADIWG::Mdtranslator::VERSION
	end

	Mdtranslator.start(ARGV)

end
