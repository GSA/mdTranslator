#!/usr/bin/env ruby
# ADIwg mdTranslator - Thor CLI for mdtranslator

# History:
# 	Stan Smith 2014-07-15 original script
#   Stan Smith 2014-09-02 changed name to mdtranslator
#   Stan Smith 2014-09-21 coded cli to 0.8.0 api

require 'thor'
require 'adiwg-mdtranslator'

class Mdtranslator < Thor

	# exit_on_failure added to exit with code 1 if thor cannot complete task
	# such as if required parameters are missing
	def self.exit_on_failure?
		true
	end

	# basic cli description
	desc 'translate [FILE]', %q{Pass JSON string or filename plus parameters to mdtranslator translate}
	long_desc <<-LONGDESC
	    'mdtranslator translate' provides command line access to the ADIWG metadata translator
 with options to select the input file reader, select writer output format, show empty tags
 in XML outputs, and choose level of validation for JSON inputs.
	LONGDESC
	# define cli options
	method_option :reader, :aliases => '-r', :desc => 'Name of reader to read your input', :default => 'adiwgJson'
	method_option :writer, :aliases => '-w', :desc => 'Name of writer to create your metadata, or leave blank to validate input only'
	method_option :validate, :aliases => '-v', :desc => 'Specify level of validation to be performed', :enum => %w{none normal strict}, :default => 'normal'
	method_option :showAllTags, :aliases => '-s', :desc => 'Include tags for unused attributes', :type => :boolean, :default => false
	method_option :messages, :aliases => '-m', :desc => 'On error return messages as formatted text or json object', :enum => %w{json text}, :default => 'text'
	method_option :returnObject, :aliases => '-o', :desc => 'Return full JSON object generated by translator', :type => :boolean, :default => false

	# accept command and options
	def translate(file)

		# test to see if file parameter is a local file
		# if not ... it is assumed to be a json string
		if File.exist?(file)
			# read file
			my_file = File.open(file, 'r')
			fileObj = my_file.read
			my_file.close
		else
			fileObj = file
		end

		# call mdtranslator
		mdReturn = ADIWG::Mdtranslator.translate(fileObj, options[:reader], options[:writer],
												 options[:validate], options[:showAllTags])

		# determine return content and type of return ...
		if mdReturn[:readerStructurePass] && mdReturn[:readerValidationPass]

			# no problem was found with the input file
			if options[:writer].nil?
				# if no writer was specified the input was being validated only,
				# ...no writer output will have been generated,
				# ...and the return will be a string unless json was requested
				if options[:messages] == 'json'
					$stdout.write mdReturn.to_json
					return
				else
					$stdout.write 'Success'
					return
				end
			else
				# a writer was specified,
				# output is expected from the translator's writer
				if mdReturn[:writerPass]
				    # writer output was generated
					# ...return the writer output in its native format unless json was requested
					if options[:returnObject]
						$stdout.write mdReturn.to_json
						return
					else
						$stdout.write mdReturn[:writerOutput].to_s
						return
					end
				else
					# the writer failed or generated warnings to be reported
					# ...return the messages as a string unless json was requested
					if options[:messages] == 'json'
						$stdout.write mdReturn.to_json
						return
					else
						# build a string with messages issues from parser and validator
						s = ''
						s += "Failed\n"
						s += "Writer failed to generate output or issued significant warnings\n"
						s += "See following messages for further information\n"

						# post structure messages
						i = 0
						mdReturn[:writerMessages].each do |message|
							i += 1
							s += "\nMessage: #{i}\n"
							s += message + "\n"
						end

						$stdout.write s
						return

					end
				end
			end

		else

			# problems were found with the input file

			# if no writer was specified the input was being validated only,
			# ...no writer output will have been generated,
			# ...and return is always expected to be a string
			if options[:messages] == 'json'
				$stdout.write mdReturn.to_json
				return
			else
				# build a string with messages issues from parser and validator
				s = ''
				s += "Failed\n"
				s += "Input failed to pass either file structure validation or content does not match schema\n"
				s += "See following messages for further information\n"

				# post structure messages
				if mdReturn[:readerStructurePass]
					s += "Success - Input structure is valid\n"
				else
					s += "Fail - Structure of input file is invalid - see following message(s):\n"
					i = 0
					mdReturn[:readerStructureMessages].each do |message|
						i += 1
						s += "\nMessage: #{i}\n"
						s += message.to_s + "\n"
					end
				end

				# post validator messages
				unless mdReturn[:readerValidationPass].nil?
					if mdReturn[:readerValidationPass]
						s += "Success - Input content passes schema definition\n"
					else
						s += "Fail - Input content did not pass schema validation - see following message(s):\n"
						i = 0
						mdReturn[:readerValidationMessages].each do |message|
							i += 1
							s += "\nMessage: #{i}\n"
							s += message.to_s + "\n"
						end
					end
				end

				$stdout.write s
				return

			end
		end

	end

	Mdtranslator.start(ARGV)

end
